import React, { useState, useEffect, useRef, useCallback } from "react";
import { View, ScrollView, StyleSheet, Text, TouchableOpacity, TextInput, Alert, ActivityIndicator, Platform, Modal } from "react-native";
import AsyncStorage from "@react-native-async-storage/async-storage";
import { Feather, MaterialCommunityIcons, Ionicons } from "@expo/vector-icons";
import ConfettiCannon from "react-native-confetti-cannon";
import NetInfo from "@react-native-community/netinfo";
import firebase from "firebase/compat/app";
import "firebase/compat/firestore";
import { SafeAreaView, SafeAreaProvider } from "react-native-safe-area-context";
import RNPickerSelect from "react-native-picker-select";

// Import the new animation libraries
import Animated, { 
  useSharedValue, 
  useAnimatedStyle, 
  withTiming, 
  withSpring,
  Easing,
  runOnJS,
  interpolate
} from 'react-native-reanimated';

// ========== CONSTANTS & HELPERS ==========

const APP_VERSION = "1.0.1";
const BUILD_DATE = "2025-06-08";
const CURRENT_DATE = "2025-06-08";
const CURRENT_TIME = "23:41:52";

// New design system colors
const colors = {
  primary: '#2563eb',
  secondary: '#3b82f6',
  success: '#22c55e',
  warning: '#f59e0b',
  danger: '#ef4444',
  neutral: {
    50: '#f8fafc',
    100: '#f1f5f9',
    200: '#e2e8f0',
    300: '#cbd5e1',
    400: '#94a3b8',
    500: '#64748b',
    600: '#475569',
    700: '#334155',
    800: '#1e293b',
    900: '#0f172a',
  }
};

const typography = {
  h1: { fontSize: 28, fontWeight: '700', color: colors.neutral[900] },
  h2: { fontSize: 24, fontWeight: '600', color: colors.neutral[800] },
  h3: { fontSize: 20, fontWeight: '600', color: colors.neutral[700] },
  h4: { fontSize: 18, fontWeight: '600', color: colors.neutral[700] },
  body: { fontSize: 16, color: colors.neutral[600] },
  bodyLarge: { fontSize: 18, color: colors.neutral[600] },
  caption: { fontSize: 14, color: colors.neutral[500] },
  small: { fontSize: 12, color: colors.neutral[500] },
};

const commonUKBreeds = [
  "Labrador Retriever",
  "Cocker Spaniel",
  "French Bulldog",
  "Bulldog",
  "Dachshund",
  "German Shepherd",
  "Jack Russell Terrier",
  "Staffordshire Bull Terrier",
  "Border Collie",
  "Golden Retriever"
];

const breedTips = {
  "Labrador Retriever": [
    "Labradors love water – include swimming in their routine.",
    "They respond well to food rewards but watch their weight."
  ],
  "Cocker Spaniel": [
    "Spaniels are energetic and need regular, varied exercise.",
    "Mental stimulation is crucial for this clever breed."
  ],
  "French Bulldog": [
    "Short walks suit their breathing; avoid heat.",
    "They thrive on companionship and gentle training."
  ],
  "Bulldog": [
    "Keep sessions short and allow rest breaks.",
    "Monitor for overheating, especially in warm weather."
  ],
  "Dachshund": [
    "Protect their back: avoid stairs and jumping.",
    "Short, positive training sessions work best."
  ],
  "German Shepherd": [
    "GSDs need jobs: try agility or advanced obedience.",
    "Early and ongoing socialisation is key."
  ],
  "Jack Russell Terrier": [
    "Channel their energy into games and puzzles.",
    "Consistent boundaries are essential."
  ],
  "Staffordshire Bull Terrier": [
    "They excel with positive reinforcement.",
    "Plenty of social play helps prevent boredom."
  ],
  "Border Collie": [
    "They thrive on advanced tricks and mental work.",
    "Provide daily tasks to keep them busy."
  ],
  "Golden Retriever": [
    "Retrievers love to carry and fetch – use this in games.",
    "Social, gentle training is most effective."
  ]
};

const firebaseConfig = {
  apiKey: "AIzaSyDPT2FZbLupAd9F_V1CB87i5CUl2oaULLg",
  authDomain: "ludos-training-tracker.firebaseapp.com",
  projectId: "ludos-training-tracker",
  storageBucket: "ludos-training-tracker.appspot.com",
  messagingSenderId: "599255592851",
  appId: "1:599255592851:android:5c758bc134326f9b40c266"
};

if (!firebase.apps.length) {
  firebase.initializeApp(firebaseConfig);
  firebase.firestore().enablePersistence({ synchronizeTabs: false }).catch(function(err) { 
    console.error("Firestore persistence error:", err); 
  });
}
const db = firebase.firestore();

const trainingStages = {
  1: { name: "Foundation (Weeks 1-4)", range: "8-12 weeks", color: "#bbf7d0" },
  2: { name: "Impulse Control (Weeks 5-16)", range: "12-16 weeks", color: "#dbeafe" },
  3: { name: "Building Obedience (Weeks 17-26)", range: "4-6 months", color: "#ede9fe" },
  4: { name: "Adolescent Phase (Weeks 27+)", range: "6-12 months", color: "#fed7aa" }
};

const weeklyPlans = {
  1: ["Name recognition", "Crate training", "Potty training"],
  2: ["Sit & Down", "Handling paws/ears/mouth", "Intro to leash"],
  3: ["Meet calm dogs", "New surfaces & sounds", "Short training sessions"],
  4: ["Basic recall (indoors)", "Continue potty/crate", "Social walk (carry if needed)"],
  5: ["Wait & Leave it", "Loose-leash walking", "Puzzle toy intro"],
  6: ["Sit-Stay & Down-Stay", "Recall indoors", "Traffic & bike exposure"],
  7: ["Tug with drop-it", "Find-it game", "New sounds/social areas"],
  8: ["Reinforce all basics", "Puzzle time", "Crate review"],
  9: ["Recall w/ distractions", "Advanced stays", "Marker word training"],
  10: ["Place command", "Puzzle toy advanced", "Spin trick"],
  11: ["Scent games", "Shake trick", "Review leash & crate"],
  12: ["Bow trick", "New distractions", "Clicker practice"],
  13: ["Mix tricks: combo day", "Trail walk intro", "Social calm practice"],
  14: ["Stays with duration", "Heel in quiet area", "Slow feeder puzzle"],
  15: ["Clicker games", "Play with purpose", "Place & Stay combo"],
  16: ["Dog-friendly cafe visit", "New location recall", "Tug with control"]
};

const dailyRoutine = {
  morning: ["Potty break", "Breakfast", "Basic commands review"],
  midday: ["Primary training focus", "Socialization/Exposure", "Mental stimulation"],
  evening: ["Recall practice", "Command reinforcement", "Cool down"],
  play: ["Structured play", "Bonding time", "Free play"]
};

const MAX_WEEKS = 16;

// Utility functions
const getCurrentStage = week => {
  if (week <= 4) return 1;
  if (week <= 16) return 2;
  if (week <= 26) return 3;
  return 4;
};

const isValidDate = (dateString) => {
  if (!/^\d{4}-\d{2}-\d{2}$/.test(dateString)) return false;
  const date = new Date(dateString + 'T00:00:00.000Z');
  return !isNaN(date) && dateString === date.toISOString().slice(0, 10);
};

const deepEqual = (obj1, obj2) => {
  if (obj1 === obj2) return true;
  if (obj1 == null || obj2 == null) return false;
  if (typeof obj1 !== typeof obj2) return false;
  
  if (typeof obj1 !== 'object') return obj1 === obj2;
  
  const keys1 = Object.keys(obj1);
  const keys2 = Object.keys(obj2);
  
  if (keys1.length !== keys2.length) return false;
  
  for (let key of keys1) {
    if (!keys2.includes(key)) return false;
    if (!deepEqual(obj1[key], obj2[key])) return false;
  }
  
  return true;
};

function calcDogAge(dob, weekOffset = 0, nowDate) {
  if (!dob) return "";
  const dobDate = new Date(dob);
  if (isNaN(dobDate)) return "";
  let baseTime = nowDate ? nowDate.getTime() : Date.now();
  let virtualDate = new Date(dobDate.getTime() + weekOffset * 7 * 24 * 60 * 60 * 1000);
  let diff = baseTime - virtualDate.getTime();
  if (diff < 0) diff = 0;
  let ageDate = new Date(diff);
  let years = ageDate.getUTCFullYear() - 1970;
  let months = ageDate.getUTCMonth();
  let days = ageDate.getUTCDate() - 1;
  let weeks = Math.floor(days / 7);
  let ageStr = "";
  if (years > 0) ageStr += `${years}y `;
  if (months > 0) ageStr += `${months}m `;
  if (weeks > 0) ageStr += `${weeks}w`;
  if (!ageStr) ageStr = "0w";
  return ageStr.trim();
}

async function updateDogInfoStorageAndFirestore(familyId, name, breed, dob) {
  await AsyncStorage.setItem("dogName", name);
  await AsyncStorage.setItem("dogBreed", breed);
  await AsyncStorage.setItem("dogDob", dob);
  if (familyId) {
    await db.collection("families").doc(familyId).set(
      { dogName: name, dogBreed: breed, dogDob: dob },
      { merge: true }
    );
  }
}

// ========== ANIMATED COMPONENTS ==========
const AnimatedProgressBar = ({ progress, color = colors.success, height = 8 }) => {
  const width = useSharedValue(0);

  useEffect(() => {
    width.value = withTiming(progress * 100, {
      duration: 800,
      easing: Easing.out(Easing.quad),
    });
  }, [progress, width]);

  const animatedStyle = useAnimatedStyle(() => {
    return {
      width: `${width.value}%`,
    };
  });

  return (
    <View style={[styles.progressBar, { height }]}>
      <Animated.View
        style={[
          styles.progressFill,
          {
            backgroundColor: color,
          },
          animatedStyle,
        ]}
      />
    </View>
  );
};

const AnimatedActivityCard = ({ children, isCompleted, onPress }) => {
  const scale = useSharedValue(1);
  const opacity = useSharedValue(1);

  const handlePress = useCallback(() => {
    scale.value = withSpring(0.95, { duration: 100 }, () => {
      scale.value = withSpring(1, { duration: 200 });
    });
    
    runOnJS(onPress)();
  }, [onPress, scale]);

  const animatedStyle = useAnimatedStyle(() => {
    return {
      transform: [{ scale: scale.value }],
      opacity: opacity.value,
    };
  });

  useEffect(() => {
    opacity.value = withTiming(isCompleted ? 0.8 : 1, { duration: 300 });
  }, [isCompleted, opacity]);

  return (
    <TouchableOpacity onPress={handlePress} activeOpacity={0.7}>
      <Animated.View
        style={[
          styles.activityCard,
          isCompleted && styles.completedActivity,
          animatedStyle,
        ]}
      >
        {children}
      </Animated.View>
    </TouchableOpacity>
  );
};

// ========== ERROR BOUNDARY ==========
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    console.error('App Error:', error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return (
        <View style={styles.errorContainer}>
          <Feather name="alert-triangle" size={48} color={colors.danger} />
          <Text style={[typography.h3, styles.errorTitle]}>Something went wrong</Text>
          <Text style={[typography.body, styles.errorText]}>Please restart the app</Text>
          <TouchableOpacity 
            style={styles.errorButton}
            onPress={() => this.setState({ hasError: false })}
          >
            <Text style={styles.errorButtonText}>Try Again</Text>
          </TouchableOpacity>
        </View>
      );
    }

    return this.props.children;
  }
}

// ========== MAIN APP COMPONENT ==========

function MainApp() {
  const [isOffline, setIsOffline] = useState(false);
  
  // Core state
  const [familyId, setFamilyId] = useState(null);
  const [dogName, setDogName] = useState(null);
  const [dogBreed, setDogBreed] = useState(null);
  const [dogDob, setDogDob] = useState(null);
  
  // Input states
  const [inputId, setInputId] = useState("");
  const [inputDog, setInputDog] = useState("");
  const [inputBreed, setInputBreed] = useState("");
  const [inputBreedOther, setInputBreedOther] = useState("");
  const [inputDob, setInputDob] = useState("");
  
  // UI states
  const [showDogInput, setShowDogInput] = useState(false);
  const [familyDogLoading, setFamilyDogLoading] = useState(true);
  const [checkingFamilyId, setCheckingFamilyId] = useState(false);
  const [loading, setLoading] = useState(true);
  const [syncing, setSyncing] = useState(false);
  
  // Edit modal states
  const [editDogModal, setEditDogModal] = useState(false);
  const [editDogName, setEditDogName] = useState("");
  const [editDogBreed, setEditDogBreed] = useState("");
  const [editDogDob, setEditDogDob] = useState("");
  const [editDogBreedOther, setEditDogBreedOther] = useState("");
  
  // App data states
  const [currentWeek, setCurrentWeek] = useState(1);
  const [completedActivities, setCompletedActivities] = useState([]);
  const [dailyNotes, setDailyNotes] = useState({});
  const [viewMode, setViewMode] = useState("daily");
  const [selectedDate, setSelectedDate] = useState(() => CURRENT_DATE);
  const [completedDailyByDate, setCompletedDailyByDate] = useState({});
  
  // Family and notes states
  const [family, setFamily] = useState([
    { id: 1, name: "Primary Trainer", editing: false },
    { id: 2, name: "Family Member 2", editing: false },
    { id: 3, name: "Family Member 3", editing: false }
  ]);
  const [newFamilyName, setNewFamilyName] = useState("");
  const [editFamilyName, setEditFamilyName] = useState({});
  const [editingMemberId, setEditingMemberId] = useState(null);
  
  const [sharedNotes, setSharedNotes] = useState([]);
  const [newSharedNote, setNewSharedNote] = useState("");
  const [notesLoading, setNotesLoading] = useState(false);
  const [editingNoteId, setEditingNoteId] = useState(null);
  const [editingNoteText, setEditingNoteText] = useState("");
  const [currentUserName, setCurrentUserName] = useState("Wiewioreq");
  
  // Celebration states
  const [showDailyConfetti, setShowDailyConfetti] = useState(false);
  const [showWeeklyConfetti, setShowWeeklyConfetti] = useState(false);
  const [currentDogAge, setCurrentDogAge] = useState(() => calcDogAge(dogDob, 0, new Date()));
  
  // Animation values
  const fadeAnim = useSharedValue(0);
  const slideAnim = useSharedValue(50);
  const headerScale = useSharedValue(0.9);
  
  // Refs for cleanup and optimization
  const syncTimeout = useRef();
  const lastSyncedData = useRef({});
  const dobInputRef = useRef(null);

  // Tab switching animation
  const animateTabSwitch = useCallback(() => {
    fadeAnim.value = withTiming(0, { duration: 150 }, () => {
      slideAnim.value = 30;
      fadeAnim.value = withTiming(1, { duration: 300 });
      slideAnim.value = withSpring(0, { damping: 15, stiffness: 200 });
    });
  }, [fadeAnim, slideAnim]);

  // Initialize animations
  useEffect(() => {
    fadeAnim.value = withTiming(1, { duration: 500 });
    slideAnim.value = withSpring(0, { damping: 15, stiffness: 100 });
    headerScale.value = withSpring(1, { damping: 10, stiffness: 100 });
  }, [fadeAnim, slideAnim, headerScale]);

  // Animated styles
  const contentAnimatedStyle = useAnimatedStyle(() => {
    return {
      opacity: fadeAnim.value,
      transform: [{ translateY: slideAnim.value }],
    };
  });

  const headerAnimatedStyle = useAnimatedStyle(() => {
    return {
      transform: [{ scale: headerScale.value }],
    };
  });

  // Network status effect
  useEffect(() => {
    const unsubscribe = NetInfo.addEventListener(state => {
      setIsOffline(!state.isConnected);
    });
    NetInfo.fetch().then(state => setIsOffline(!state.isConnected));
    return () => unsubscribe();
  }, []);

  // Cleanup timeouts on unmount
  useEffect(() => {
    return () => {
      if (syncTimeout.current) {
        clearTimeout(syncTimeout.current);
      }
    };
  }, []);

  // Initial data loading
  useEffect(() => {
    (async () => {
      try {
        const id = await AsyncStorage.getItem("familyId");
        const dog = await AsyncStorage.getItem("dogName");
        const breed = await AsyncStorage.getItem("dogBreed");
        const dob = await AsyncStorage.getItem("dogDob");
        const username = await AsyncStorage.getItem("memberName");
        
        if (id) setFamilyId(id);
        if (dog) setDogName(dog);
        if (breed) setDogBreed(breed);
        if (dob) setDogDob(dob);
        if (username) setCurrentUserName(username);
      } catch (e) {
        console.error("Error loading dog/family data:", e);
      }
      
      try {
        const cdbd = await AsyncStorage.getItem("completedDailyByDate");
        if (cdbd) {
          const parsedData = JSON.parse(cdbd);
          console.log("Loaded daily task data from storage:", parsedData);
          setCompletedDailyByDate(parsedData);
        }
      } catch (e) {
        console.error("Failed to parse completedDailyByDate:", e);
      } finally {
        setFamilyDogLoading(false);
      }
    })();
  }, []);

  // Set current user name in AsyncStorage when it changes
  useEffect(() => {
    if (currentUserName) {
      AsyncStorage.setItem("memberName", currentUserName);
    }
  }, [currentUserName]);

  // Optimized Firebase sync with deep comparison
  const syncToFirebase = useCallback(async (data) => {
    if (!familyId || !data) return;
    
    // Only sync if data actually changed
    if (deepEqual(lastSyncedData.current, data)) {
      setSyncing(false);
      return;
    }
    
    try {
      setSyncing(true);
      await db.collection("families").doc(familyId).set(data, { merge: true });
      lastSyncedData.current = { ...data };
      console.log("Data synced to Firebase successfully");
    } catch (e) {
      console.error("Failed to sync to Firebase:", e);
      if (!isOffline) {
        Alert.alert("Sync Error", "Failed to save changes. Please check your connection.");
      }
    } finally {
      setSyncing(false);
    }
  }, [familyId, isOffline]);

  // Consolidated debounced sync effect
  useEffect(() => {
    if (loading || !familyId) return;
    
    const dataToSync = {
      currentWeek,
      completedActivities,
      dailyNotes,
      dogName,
      dogBreed,
      dogDob,
      family,
      sharedNotes,
      completedDailyByDate
    };
    
    // Clear existing timeout
    if (syncTimeout.current) {
      clearTimeout(syncTimeout.current);
    }
    
    // Debounce sync by 500ms
    syncTimeout.current = setTimeout(() => {
      syncToFirebase(dataToSync);
      // Also save to AsyncStorage for offline access
      AsyncStorage.setItem("completedDailyByDate", JSON.stringify(completedDailyByDate))
        .catch(e => console.error("AsyncStorage save error", e));
    }, 500);
    
  }, [currentWeek, completedActivities, dailyNotes, dogName, dogBreed, dogDob, family, sharedNotes, completedDailyByDate, syncToFirebase, loading, familyId]);

  // Firebase snapshot listener with optimized updates
  useEffect(() => {
    if (!familyId) return;
    
    setLoading(true);
    setNotesLoading(true);
    
    const unsubscribe = db
      .collection("families")
      .doc(familyId)
      .onSnapshot(
        docSnap => {
          if (docSnap.exists) {
            const data = docSnap.data();
            
            // Only update state if values actually changed (reduces re-renders)
            if (data.currentWeek !== undefined && data.currentWeek !== currentWeek) {
              setCurrentWeek(data.currentWeek);
            }
            
            if (data.completedActivities && !deepEqual(data.completedActivities, completedActivities)) {
              setCompletedActivities(data.completedActivities);
            }
            
            if (data.dailyNotes && !deepEqual(data.dailyNotes, dailyNotes)) {
              setDailyNotes(data.dailyNotes);
            }
            
            if (data.family && !deepEqual(data.family, family)) {
              setFamily(data.family);
            }
            
            if (data.sharedNotes && !deepEqual(data.sharedNotes, sharedNotes)) {
              setSharedNotes(data.sharedNotes);
            }
            
            if (data.dogName && data.dogName !== dogName) {
              setDogName(data.dogName);
              AsyncStorage.setItem("dogName", data.dogName);
            }
            
            if (data.dogBreed && data.dogBreed !== dogBreed) {
              setDogBreed(data.dogBreed);
              AsyncStorage.setItem("dogBreed", data.dogBreed);
            }
            
            if (data.dogDob && data.dogDob !== dogDob) {
              setDogDob(data.dogDob);
              AsyncStorage.setItem("dogDob", data.dogDob);
            }
            
            if (data.completedDailyByDate && !deepEqual(data.completedDailyByDate, completedDailyByDate)) {
              setCompletedDailyByDate(data.completedDailyByDate);
              AsyncStorage.setItem("completedDailyByDate", JSON.stringify(data.completedDailyByDate))
                .catch(e => console.error("AsyncStorage save error", e));
            }
            
            // Update lastSyncedData to prevent immediate re-sync
            lastSyncedData.current = {
              currentWeek: data.currentWeek ?? 1,
              completedActivities: data.completedActivities ?? [],
              dailyNotes: data.dailyNotes ?? {},
              dogName: data.dogName,
              dogBreed: data.dogBreed,
              dogDob: data.dogDob,
              family: data.family ?? [],
              sharedNotes: data.sharedNotes ?? [],
              completedDailyByDate: data.completedDailyByDate ?? {}
            };
          }
          setLoading(false);
          setNotesLoading(false);
        },
        err => {
          setLoading(false);
          setNotesLoading(false);
          console.error("Firestore snapshot error:", err);
          if (!isOffline) {
            Alert.alert("Sync error", "Could not sync with Firebase: " + err.message);
          }
        }
      );
    
    return unsubscribe;
  }, [familyId]);

  // Dog age calculation effect
  useEffect(() => {
    if (!dogDob) return;
    const interval = setInterval(() => {
      setCurrentDogAge(calcDogAge(dogDob, 0, new Date()));
    }, 60 * 1000);
    setCurrentDogAge(calcDogAge(dogDob, 0, new Date()));
    return () => clearInterval(interval);
  }, [dogDob]);

  // Family ID submission
  const handleFamilyIdSubmit = async () => {
    if (!inputId.trim()) return;
    setCheckingFamilyId(true);
    const famId = inputId.trim();
    
    try {
      const docSnap = await db.collection("families").doc(famId).get();
      if (docSnap.exists) {
        const data = docSnap.data();
        if (data.dogName && data.dogBreed && data.dogDob) {
          await AsyncStorage.setItem("familyId", famId);
          await AsyncStorage.setItem("dogName", data.dogName);
          await AsyncStorage.setItem("dogBreed", data.dogBreed);
          await AsyncStorage.setItem("dogDob", data.dogDob);
          setFamilyId(famId);
          setDogName(data.dogName);
          setDogBreed(data.dogBreed);
          setDogDob(data.dogDob);
          setCheckingFamilyId(false);
          setShowDogInput(false);
        } else {
          Alert.alert("Family ID Exists", "This Family ID exists but is missing some dog info. Please contact your admin.");
          setCheckingFamilyId(false);
        }
      } else {
        Alert.alert(
          "Create New Family?",
          `No family found for ID "${famId}". Do you want to create a new family with this ID?`,
          [
            { text: "Cancel", style: "cancel", onPress: () => setCheckingFamilyId(false) },
            { text: "Create", style: "default", onPress: () => { setShowDogInput(true); setCheckingFamilyId(false); } }
          ]
        );
      }
    } catch (e) {
      Alert.alert("Network error", e.message);
      setCheckingFamilyId(false);
    }
  };

  // Dog details submission with improved validation
  const handleDogDetailsSubmit = async () => {
    const breedToSave = inputBreed === "Other" ? inputBreedOther.trim() : inputBreed;
    
    if (!inputId.trim() || !inputDog.trim() || !breedToSave || !inputDob.trim()) {
      Alert.alert("Missing Information", "Please fill in all required fields.");
      return;
    }
    
    if (inputBreed === "Other" && !inputBreedOther.trim()) {
      Alert.alert("Breed Required", "Please specify the breed.");
      return;
    }
    
    if (!isValidDate(inputDob.trim())) {
      Alert.alert("Invalid Date", "Please enter a valid date in YYYY-MM-DD format.");
      return;
    }
    
    const famId = inputId.trim();
    const dName = inputDog.trim();
    const dBreed = breedToSave;
    const dDob = inputDob.trim();
    
    try {
      await db.collection("families").doc(famId).set({
        dogName: dName,
        dogBreed: dBreed,
        dogDob: dDob,
        family: [
          { id: 1, name: "Primary Trainer", editing: false },
          { id: 2, name: "Family Member 2", editing: false },
          { id: 3, name: "Family Member 3", editing: false }
        ]
      }, { merge: true });
      
      await AsyncStorage.setItem("familyId", famId);
      await AsyncStorage.setItem("dogName", dName);
      await AsyncStorage.setItem("dogBreed", dBreed);
      await AsyncStorage.setItem("dogDob", dDob);
      
      setFamilyId(famId);
      setDogName(dName);
      setDogBreed(dBreed);
      setDogDob(dDob);
      setShowDogInput(false);
    } catch (e) {
      Alert.alert("Network error", e.message);
    }
  };

  // Daily activity toggle with optimistic UI updates
  const today = CURRENT_DATE;
  const completedToday = completedDailyByDate[today] || [];
  
  const toggleDailyActivity = useCallback((timeSlot, activity) => {
    const key = `daily-${timeSlot}-${activity}`;
    
    setCompletedDailyByDate(prev => {
      const prevForToday = prev[today] || [];
      const isCompleted = prevForToday.includes(key);
      
      const updatedData = {
        ...prev,
        [today]: isCompleted 
          ? prevForToday.filter(k => k !== key)
          : [...prevForToday, key]
      };
      
      return updatedData;
    });
  }, [today]);

  // Notes handling with direct Firebase save
  const addNote = useCallback(async (date, note) => {
    const updatedNotes = { ...dailyNotes, [date]: note };
    setDailyNotes(updatedNotes);
    
    // Direct save to Firebase for immediate persistence
    if (familyId) {
      try {
        await db.collection("families").doc(familyId).set(
          { dailyNotes: updatedNotes }, 
          { merge: true }
        );
      } catch (e) {
        console.error("Failed to save daily note:", e);
      }
    }
  }, [dailyNotes, familyId]);

  const handleAddSharedNote = async () => {
    const trimmed = newSharedNote.trim();
    if (!trimmed) return;
    
    const author = currentUserName || (family && family.length > 0 ? family[0].name : "You");
    
    const noteObj = {
      id: Date.now().toString() + Math.random().toString(36).slice(2),
      text: trimmed,
      author,
      timestamp: new Date().toISOString(),
      authorId: currentUserName
    };
    
    const updatedNotes = [noteObj, ...(sharedNotes || [])];
    
    // Optimistic update
    setSharedNotes(updatedNotes);
    setNewSharedNote("");
    
    // Save to Firebase
    try {
      await db.collection("families").doc(familyId).set(
        { sharedNotes: updatedNotes },
        { merge: true }
      );
    } catch (e) {
      console.error("Failed to save shared note:", e);
      Alert.alert("Error", "Failed to save note. Please try again.");
      // Revert optimistic update on error
      setSharedNotes(sharedNotes);
      setNewSharedNote(trimmed);
    }
  };

  const saveNoteEdit = async (noteId) => {
    if (!editingNoteText.trim()) {
      Alert.alert("Cannot save", "Note cannot be empty.");
      return;
    }

    const updatedNotes = sharedNotes.map(note =>
      note.id === noteId ? { 
        ...note, 
        text: editingNoteText.trim(),
        edited: true,
        editTimestamp: new Date().toISOString()
      } : note
    );
    
    // Optimistic update
    setSharedNotes(updatedNotes);
    setEditingNoteId(null);
    setEditingNoteText("");
    
    try {
      await db.collection("families").doc(familyId).set(
        { sharedNotes: updatedNotes },
        { merge: true }
      );
    } catch (e) {
      console.error("Failed to update note:", e);
      Alert.alert("Error", "Failed to update the note. Please try again.");
    }
  };

  // Activity calculations
  const allDailyKeys = Object.entries(dailyRoutine)
    .flatMap(([slot, acts]) =>
      acts.map(activity => `daily-${slot}-${activity}`)
    );
  const completedDaily = completedToday.length;
  const dailyRate = allDailyKeys.length > 0 ? completedDaily / allDailyKeys.length : 0;
  
  const completionRate = (() => {
    const currentWeekActivities = weeklyPlans[currentWeek] || [];
    const completed = currentWeekActivities.filter(act =>
      completedActivities.includes(`${currentWeek}-${act}`)
    ).length;
    return currentWeekActivities.length
      ? completed / currentWeekActivities.length
      : 0;
  })();

  // Confetti effects
  useEffect(() => {
    if (dailyRate === 1 && !showDailyConfetti) {
      setShowDailyConfetti(true);
      setTimeout(() => setShowDailyConfetti(false), 3500);
    }
  }, [dailyRate, showDailyConfetti]);

  useEffect(() => {
    const currentWeekActivities = weeklyPlans[currentWeek] || [];
    const allDone = currentWeekActivities.every(act =>
      completedActivities.includes(`${currentWeek}-${act}`)
    );
    if (allDone && !showWeeklyConfetti && currentWeekActivities.length > 0) {
      setShowWeeklyConfetti(true);
      setTimeout(() => setShowWeeklyConfetti(false), 3500);
    }
  }, [currentWeek, completedActivities, showWeeklyConfetti]);

  // Activity toggle
  const toggleActivity = useCallback((week, activity) => {
    let key;
    if (week === "milestone") {
      key = `milestone-${activity}`;
    } else {
      key = `${week}-${activity}`;
    }
    setCompletedActivities(prev =>
      prev.includes(key) ? prev.filter(k => k !== key) : [...prev, key]
    );
  }, []);

  const currentStage = getCurrentStage(currentWeek);

  // Family member management
  const handleEditFamilyMember = useCallback(id => {
    setEditingMemberId(id);
    setEditFamilyName({ ...editFamilyName, [id]: family.find(f => f.id === id)?.name || "" });
  }, [editFamilyName, family]);

  const handleSaveFamilyMember = useCallback((id, newName) => {
    setFamily(family =>
      family.map(f =>
        f.id === id ? { ...f, name: newName || "Unnamed", editing: false } : f
      )
    );
    setEditingMemberId(null);
  }, []);

  const handleRemoveFamilyMember = useCallback(id => {
    Alert.alert(
      "Remove member",
      "Are you sure you want to remove this family member?",
      [
        { text: "Cancel", style: "cancel" },
        {
          text: "Remove",
          style: "destructive",
          onPress: () => setFamily(family => family.filter(f => f.id !== id))
        }
      ]
    );
  }, []);

  const handleAddFamilyMember = useCallback(() => {
    if (!newFamilyName.trim()) return;
    setFamily(family => [...family, { id: Date.now(), name: newFamilyName, editing: false }]);
    setNewFamilyName("");
  }, [newFamilyName]);

  // Dog editing modal with improved validation
  const openEditDogModal = useCallback(() => {
    try {
      const currentName = dogName || "";
      
      let currentBreed = "Other";
      let currentBreedOther = "";
      
      if (dogBreed) {
        if (commonUKBreeds.includes(dogBreed)) {
          currentBreed = dogBreed;
        } else {
          currentBreed = "Other";
          currentBreedOther = dogBreed;
        }
      }
      
      const currentDob = dogDob || "";
      
      setEditDogName(currentName);
      setEditDogBreed(currentBreed);
      setEditDogBreedOther(currentBreedOther);
      setEditDogDob(currentDob);
      setEditDogModal(true);
      
    } catch (e) {
      console.error("Error opening dog edit modal:", e);
      Alert.alert("Error", "Could not open the edit form. Please try again.");
    }
  }, [dogName, dogBreed, dogDob]);

  const saveDogInfo = async () => {
    // Enhanced null checks
    const name = editDogName?.trim() || "";
    const dob = editDogDob?.trim() || "";
    const breedOther = editDogBreedOther?.trim() || "";
    
    let breedToSave = editDogBreed === "Other" ? breedOther : editDogBreed;
    
    if (!name || !breedToSave || !dob) {
      Alert.alert("Missing Info", "All fields are required.");
      return;
    }
    
    if (editDogBreed === "Other" && !breedOther) {
      Alert.alert("Breed Required", "Please specify the breed.");
      return;
    }
    
    if (!isValidDate(dob)) {
      Alert.alert("Invalid Date", "Please enter a valid date in YYYY-MM-DD format.");
      return;
    }
    
    try {
      setDogName(name);
      setDogBreed(breedToSave);
      setDogDob(dob);
      
      await updateDogInfoStorageAndFirestore(familyId, name, breedToSave, dob);
      setEditDogModal(false);
    } catch (e) {
      Alert.alert("Network error", e.message);
    }
  };

  const handleLogout = async () => {
    setFamilyDogLoading(true);
    await AsyncStorage.removeItem("familyId");
    await AsyncStorage.removeItem("dogName");
    await AsyncStorage.removeItem("dogBreed");
    await AsyncStorage.removeItem("dogDob");
    await AsyncStorage.removeItem("completedDailyByDate");
    setFamilyId(null);
    setDogName(null);
    setDogBreed(null);
    setDogDob(null);
    setInputId("");
    setInputDog("");
    setInputBreed("");
    setInputBreedOther("");
    setInputDob("");
    setShowDogInput(false);
    setFamilyDogLoading(false);
  };

  const navigationTabs = [
    { key: "daily", iconLib: Feather, iconName: "calendar" },
    { key: "weekly", iconLib: Feather, iconName: "clock" },
    { key: "progress", iconLib: Feather, iconName: "trending-up" },
    { key: "family", iconLib: Feather, iconName: "users" },
    { key: "notes", iconLib: Feather, iconName: "sticky-note" }
  ];

  // Tab press with animation
  const handleTabPress = useCallback((tabKey) => {
    setViewMode(tabKey);
    animateTabSwitch();
  }, [animateTabSwitch]);

  // Loading states
  if (familyDogLoading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color={colors.primary} />
        <Text style={[typography.body, styles.loadingText]}>Loading…</Text>
      </View>
    );
  }

  // Setup screens
  if (!familyId || !dogName || !dogBreed || !dogDob) {
    if (!showDogInput) {
      return (
        <View style={styles.setupContainer}>
          <Text style={[typography.h1, styles.welcomeTitle]}>Welcome!</Text>
          <Text style={[typography.body, styles.setupText]}>
            Enter your Family ID to sync training data with your household.
          </Text>
          <Text style={[typography.caption, styles.setupSubtext]}>
            Use the same Family ID on all your family's devices. Create a new one or enter an existing ID to join.
          </Text>
          <TextInput
            placeholder="Family ID (e.g. ludo-smiths)"
            value={inputId}
            onChangeText={setInputId}
            style={styles.setupInput}
          />
          <TouchableOpacity onPress={handleFamilyIdSubmit} style={styles.setupButton}>
            {checkingFamilyId
              ? <ActivityIndicator size="small" color="#fff"/>
              : <Text style={[typography.body, styles.setupButtonText]}>Continue</Text>
            }
          </TouchableOpacity>
        </View>
      );
    } else {
      return (
        <View style={styles.setupContainer}>
          <Text style={[typography.h1, styles.welcomeTitle]}>Create a New Family Group</Text>
          <Text style={[typography.body, styles.setupText]}>
            Set your Family ID and Dog's Details (only needed once).
          </Text>
          <TextInput
            value={inputId}
            editable={false}
            style={[styles.setupInput, styles.disabledInput]}
          />
          <TextInput
            placeholder="Dog Name (e.g. Ludo)"
            value={inputDog}
            onChangeText={setInputDog}
            style={styles.setupInput}
          />
          <RNPickerSelect
            onValueChange={value => setInputBreed(value)}
            value={inputBreed}
            placeholder={{ label: "Select Dog Breed...", value: "" }}
            items={[
              ...commonUKBreeds.map(breed => ({ label: breed, value: breed })),
              { label: "Other", value: "Other" }
            ]}
            style={{
              inputIOS: styles.pickerInput,
              inputAndroid: styles.pickerInput
            }}
          />
          {inputBreed === "Other" && (
            <TextInput
              placeholder="Type breed"
              value={inputBreedOther}
              onChangeText={setInputBreedOther}
              style={styles.setupInput}
            />
          )}
          <TextInput
            placeholder="Date of Birth (YYYY-MM-DD)"
            value={inputDob}
            onChangeText={setInputDob}
            keyboardType={Platform.OS === "ios" ? "numbers-and-punctuation" : "numeric"}
            style={styles.setupInput}
            ref={dobInputRef}
            maxLength={10}
          />
          <TouchableOpacity onPress={handleDogDetailsSubmit} style={styles.setupButton}>
            <Text style={[typography.body, styles.setupButtonText]}>Create Family</Text>
          </TouchableOpacity>
        </View>
      );
    }
  }

  if (loading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color={colors.primary} />
        <Text style={[typography.body, styles.loadingText]}>Loading training progress…</Text>
      </View>
    );
  }

  return (
    <SafeAreaView style={styles.container} edges={['top', 'bottom']}>
      <View style={styles.mainContent}>
        <Animated.ScrollView 
          contentContainerStyle={styles.scrollContent}
          style={contentAnimatedStyle}
        >
          {isOffline && (
            <View style={styles.offlineBanner}>
              <Feather name="wifi-off" size={18} color="#fff" />
              <Text style={[typography.caption, styles.offlineText]}>You are offline. Changes will sync when back online.</Text>
            </View>
          )}
          
          {showDailyConfetti && (
            <>
              <ConfettiCannon key="daily-confetti" count={120} origin={{x: 200, y: 0}} fadeOut autoStart />
              <View style={styles.celebrationBanner}>
                <Feather name="award" size={30} color={colors.warning} />
                <Text style={[typography.h4, styles.celebrationText]}>Daily Goal Complete! Well done!</Text>
              </View>
            </>
          )}

          {showWeeklyConfetti && (
            <>
              <ConfettiCannon key="weekly-confetti" count={200} origin={{x: 200, y: 0}} fadeOut autoStart />
              <View style={styles.celebrationBanner}>
                <Feather name="star" size={30} color={colors.warning} />
                <Text style={[typography.h4, styles.celebrationText]}>Week Complete! Amazing progress!</Text>
              </View>
            </>
          )}

          {/* Header Section with improved styling */}
          <Animated.View style={[styles.headerGradient, headerAnimatedStyle]}>
            <View style={styles.headerRow}>
              <View style={styles.headerInfo}>
                <Text style={[typography.h2, styles.headerTitle]}>🐕 {dogName}'s Training Journey</Text>
                <Text style={[typography.body, styles.headerSubtitle]}>
                  Family ID: <Text style={styles.familyId}>{familyId}</Text>
                </Text>
                <Text style={[typography.body, styles.headerSubtitle]}>
                  {dogBreed} • Week {currentWeek} • {trainingStages[currentStage].name}
                </Text>
                <Text style={[typography.body, styles.headerSubtitle]}>
                  Age: <Text style={styles.dogAge}>{currentDogAge}</Text>
                  {"  "}DOB: <Text style={styles.dogDob}>{dogDob}</Text>
                </Text>
                <View style={styles.statusContainer}>
                  <View style={[styles.statusBadge, isOffline ? styles.offlineStatus : styles.onlineStatus]}>
                    <Feather 
                      name={isOffline ? "wifi-off" : "wifi"} 
                      size={14} 
                      color={isOffline ? colors.danger : colors.success} 
                    />
                    <Text style={[typography.small, { color: isOffline ? colors.danger : colors.success, marginLeft: 4 }]}>
                      {isOffline ? 'Offline' : 'Online'}
                    </Text>
                  </View>
                  {syncing && (
                    <View style={[styles.statusBadge, { backgroundColor: colors.neutral[100] }]}>
                      <ActivityIndicator size={12} color={colors.primary} />
                      <Text style={[typography.small, { color: colors.primary, marginLeft: 4 }]}>Syncing</Text>
                    </View>
                  )}
                </View>
              </View>
              <View style={styles.headerStats}>
                <TouchableOpacity onPress={openEditDogModal} style={styles.editButton}>
                  <Feather name="edit-2" size={20} color={colors.primary} />
                </TouchableOpacity>
                <Text style={styles.completionPercent}>
                  {Math.round(completionRate * 100)}%
                </Text>
                <Text style={styles.completionLabel}>This Week</Text>
              </View>
            </View>
          </Animated.View>

          {/* Content based on view mode */}
          {viewMode === "daily" && (
            <View style={styles.section}>
              <View style={styles.sectionHeader}>
                <Text style={[typography.h3, styles.sectionTitle]}>Today's Training</Text>
                <Text style={[typography.caption, styles.sectionSubtitle]}>
                  {new Date().toLocaleDateString('en-GB', { 
                    weekday: 'long', 
                    year: 'numeric', 
                    month: 'long', 
                    day: 'numeric' 
                  })}
                </Text>
              </View>
              
              <View style={styles.progressContainer}>
                <View style={styles.progressHeader}>
                  <Text style={[typography.body, { fontWeight: '600' }]}>Daily Progress</Text>
                  <Text style={[typography.h4, { color: colors.primary }]}>
                    {Math.round(dailyRate * 100)}%
                  </Text>
                </View>
                <AnimatedProgressBar progress={dailyRate} />
                <Text style={[typography.caption, { marginTop: 8 }]}>
                  {completedDaily} of {allDailyKeys.length} activities completed
                </Text>
              </View>

              {Object.entries(dailyRoutine).map(([timeSlot, activities]) => (
                <View key={timeSlot} style={styles.timeSlotSection}>
                  <Text style={[typography.h4, styles.timeSlotTitle]}>
                    <Feather name="clock" size={16} />{" "}
                    {timeSlot === "play"
                      ? "Play & Bonding"
                      : `${timeSlot.charAt(0).toUpperCase() + timeSlot.slice(1)} Routine`}
                  </Text>
                  {activities.map(activity => {
                    const key = `daily-${timeSlot}-${activity}`;
                    const isCompleted = completedToday.includes(key);
                    return (
                      <AnimatedActivityCard
                        key={activity}
                        isCompleted={isCompleted}
                        onPress={() => toggleDailyActivity(timeSlot, activity)}
                      >
                        <View style={styles.activityContent}>
                          <Feather
                            name={isCompleted ? "check-circle" : "circle"}
                            size={24}
                            color={isCompleted ? colors.success : colors.neutral[400]}
                          />
                          <Text style={[
                            typography.body,
                            { 
                              marginLeft: 12,
                              color: isCompleted ? colors.success : colors.neutral[700],
                              textDecorationLine: isCompleted ? 'line-through' : 'none'
                            }
                          ]}>
                            {activity}
                          </Text>
                        </View>
                      </AnimatedActivityCard>
                    );
                  })}
                </View>
              ))}

              <View style={styles.section}>
                <Text style={[typography.h4, styles.sectionTitle]}>
                  <Feather name="star" size={18} color="#eab308" /> Week {currentWeek} Focus
                </Text>
                {(weeklyPlans[currentWeek] || []).map((activity, idx) => (
                  <TouchableOpacity
                    key={idx}
                    style={styles.activityRow}
                    onPress={() => toggleActivity(currentWeek, activity)}
                  >
                    {completedActivities.includes(`${currentWeek}-${activity}`) ? (
                      <MaterialCommunityIcons name="checkbox-marked-circle" color={colors.success} size={22} />
                    ) : (
                      <MaterialCommunityIcons name="checkbox-blank-circle-outline" color={colors.neutral[400]} size={22} />
                    )}
                    <Text
                      style={[
                        styles.activityText,
                        completedActivities.includes(`${currentWeek}-${activity}`) && styles.activityCompleted
                      ]}
                    >
                      {activity}
                    </Text>
                  </TouchableOpacity>
                ))}
              </View>
              
              <View style={styles.section}>
                <Text style={[typography.h4, styles.sectionTitle]}>
                  <Feather name="bookmark" size={18} /> Daily Notes
                </Text>
                <TextInput
                  style={styles.textInput}
                  multiline
                  placeholder={`How did ${dogName} do today?`}
                  value={dailyNotes[selectedDate] || ""}
                  onChangeText={text => addNote(selectedDate, text)}
                />
              </View>
            </View>
          )}

          {viewMode === "weekly" && (
            <View style={styles.section}>
              <View style={styles.weekNavigation}>
                <TouchableOpacity
                  onPress={() => setCurrentWeek(w => Math.max(1, w - 1))}
                  disabled={currentWeek === 1}
                  style={[styles.weekNavButton, currentWeek === 1 && styles.weekNavDisabled]}
                >
                  <Feather name="chevron-left" size={22} color={colors.primary} />
                  <Text style={styles.weekNav}>Previous Week</Text>
                </TouchableOpacity>
                <Text style={styles.weekTitle}>Week {currentWeek}</Text>
                <TouchableOpacity
                  onPress={() => setCurrentWeek(w => Math.min(MAX_WEEKS, w + 1))}
                  disabled={currentWeek === MAX_WEEKS}
                  style={[styles.weekNavButton, currentWeek === MAX_WEEKS && styles.weekNavDisabled]}
                >
                  <Text style={styles.weekNav}>Next Week</Text>
                  <Feather name="chevron-right" size={22} color={colors.primary} />
                </TouchableOpacity>
              </View>
              
              <View style={styles.weekCard}>
                <Text style={styles.weekCardTitle}>Week {currentWeek}</Text>
                <Text style={styles.weekCardAge}>
                  Age: <Text style={styles.dogAge}>{calcDogAge(dogDob)}</Text>
                </Text>
                {(weeklyPlans[currentWeek] || ["Coming soon..."]).map((activity, idx) => (
                  <TouchableOpacity
                    key={idx}
                    style={styles.activityRow}
                    onPress={() => toggleActivity(currentWeek, activity)}
                  >
                    {completedActivities.includes(`${currentWeek}-${activity}`) ? (
                      <MaterialCommunityIcons name="checkbox-marked-circle" color={colors.success} size={16} />
                    ) : (
                      <MaterialCommunityIcons name="checkbox-blank-circle-outline" color={colors.neutral[400]} size={16} />
                    )}
                    <Text
                      style={[
                        styles.activityText,
                        completedActivities.includes(`${currentWeek}-${activity}`) && styles.activityCompleted,
                        styles.smallActivityText
                      ]}
                    >
                      {activity}
                    </Text>
                  </TouchableOpacity>
                ))}
              </View>
            </View>
          )}

          {viewMode === "progress" && (
            <View style={styles.section}>
              <Text style={[typography.h3, styles.sectionTitle]}>
                <Feather name="activity" size={18} color={colors.success} /> {dogName}'s Progress Journey
              </Text>
              <View style={styles.stagesContainer}>
                {Object.entries(trainingStages).map(([stage, info]) => (
                  <View
                    key={stage}
                    style={[
                      styles.stageBox,
                      { backgroundColor: info.color, opacity: currentStage >= stage ? 1 : 0.5 }
                    ]}
                  >
                    <Text style={styles.stageName}>{info.name}</Text>
                    <Text style={styles.stageRange}>{info.range}</Text>
                  </View>
                ))}
              </View>
              
              <Text style={styles.milestonesTitle}>Key Milestones</Text>
              {[
                { week: 1, milestone: "House training established", completed: currentWeek >= 4 },
                { week: 6, milestone: "Basic commands mastered", completed: currentWeek >= 8 },
                { week: 12, milestone: "Impulse control developed", completed: currentWeek >= 16 },
                { week: 20, milestone: "Advanced obedience achieved", completed: currentWeek >= 26 },
                { week: 30, milestone: "Adolescent challenges managed", completed: currentWeek >= 35 }
              ].map((item, idx) => (
                <TouchableOpacity
                  key={idx}
                  style={styles.milestoneRow}
                  onPress={() => toggleActivity("milestone", item.milestone)}
                >
                  {completedActivities.includes(`milestone-${item.milestone}`) ? (
                    <MaterialCommunityIcons name="checkbox-marked-circle" color={colors.success} size={20} />
                  ) : (
                    <MaterialCommunityIcons name="checkbox-blank-circle-outline" color={colors.neutral[400]} size={20} />
                  )}
                  <Text
                    style={[
                      styles.activityText,
                      completedActivities.includes(`milestone-${item.milestone}`) && styles.activityCompleted
                    ]}
                  >
                    {item.milestone}
                  </Text>
                  <Text style={styles.milestoneWeek}>Week {item.week}</Text>
                </TouchableOpacity>
              ))}
            </View>
          )}

          {viewMode === "family" && (
            <View style={styles.section}>
              <View style={styles.identitySelector}>
                <Text style={[typography.h4, styles.identityTitle]}>Set Your Identity</Text>
                <Text style={[typography.caption, styles.identitySubtitle]}>
                  Select who you are on this device to edit your notes:
                </Text>
                <View style={styles.identityButtons}>
                  {family.map(member => (
                    <TouchableOpacity
                      key={member.id}
                      onPress={() => {
                        setCurrentUserName(member.name);
                        AsyncStorage.setItem("memberName", member.name);
                        Alert.alert("Identity Set", `You are now identified as ${member.name} on this device.`);
                      }}
                      style={[
                        styles.identityButton,
                        currentUserName === member.name && styles.identityButtonActive
                      ]}
                    >
                      <Text style={[
                        styles.identityButtonText,
                        currentUserName === member.name && styles.identityButtonTextActive
                      ]}>
                        {member.name}
                      </Text>
                    </TouchableOpacity>
                  ))}
                </View>
              </View>

              <Text style={[typography.h3, styles.sectionTitle]}>
                <Feather name="users" size={18} color="#a78bfa" /> Family Collaboration
              </Text>
              
              <View>
                <Text style={styles.familyTitle}>Training Team</Text>
                {family.map((member, idx) => (
                  <View key={member.id} style={styles.familyRow}>
                    <Ionicons name="person-circle" size={28} color={colors.primary} />
                    